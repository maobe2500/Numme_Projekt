%{
function [coeffVec] = dividedDifference(xVec, yVec)
    maxIndex = length(xVec);
    diffMtrx = zeros(maxIndex, maxIndex);
    diffMtrx(:, 1) = yVec;
    for j = 1:maxIndex
        for i = j:maxIndex
            dY = diffMtrx(i, j-1) - diffMtrx(i-1, j-1);
            dX = xVec(i) - xVec(i-j+1);
            diffMtrx(i, j) = dY/dX;
        if i == j:
            coeffVec(j) = diffMtrx(i, j)        % lagrar koefficienterna i en vektor
        end
    end
end

function [sum] = P_(x, coeffVec, xVec)
    sum = coeffVec(1);
    for i = 2:length(coeffVec)
        term = coeffVec(i);
        for j = 1:i
            term = term * (x - xVec(j));
        end
        sum = sum + term;
    end
end

% Does ones round of divdiffs
function [divDiffVec] = divDiff(xVec, yVec)
    for i = 1:length(xVec)-1
        currentY = yVec(i); nextY = yVec(i+1);
        currentX = xVec(i); nextX = xVec(i+1);
        divDiffVec(i) = (nextY - currentY) / (nextX - currentX);
    end
end

function [result] = P(x, coeffVec)
    result = coeffVec(1)
    for i = 2:length(coeffVec)
        result = result + coeffVec(i) * x^(i-1)
    end
end

%}


%{

function [min] = lowest(H, T)

    [tVec, rVec, rPrimeVec, phiVec, phiPrimVec, status] = RK4(H, T)
    f = @(x) rPrimeVec(x)
    TOL = 10e-6
    diff = 1
    xOld = 0
    xCurrent = 1
    while diff > TOL
        xNext = xCurrent - f(xCurrent) / (f)
    end 

end

function [tMin, phiMin, rMin] = lowest_point(H, T)
    t0 = 0;
    h = 10^-3;
    [tVec, yMtrx] = RK4(H, T);

    % data vectors
    rVec = yMtrx(:, 1);
    phiVec = yMtrx(:, 3);
    tq = t0:0.001:T;

    % Splined vectors
    rSpline = spline(tVec, rVec, tq);
    phiSpline = spline(tVec, phiVec, tq);

    % finding lowest point (t, phi, r)
    rMin = min(rSpline);
    i = find(rSpline==rMin);
    tMin = tq(i);
    phiMin = phiSpline(i);
end
%}
