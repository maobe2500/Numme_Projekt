clear all
clc

%% Funktioner, konstanter, begynnelsevärden, 
%{
KONSTANTER
g = 20 jr/h^2       - tyngsaccelerationen vid jordytan
H = 2 jr
T = ??              - sluttid
FUNKTIONER
r(t) - avståndet från jordens mitt
phi(t) - vinkeln från startpunkten
F = g/(1+H)^2 - Gravitationskraften
r'' - r*(phi')**2 = F*cos(a) - g/r**2
r''  = F*cos(a) - g/r**2 + r*(phi')**2
r*phi'' + 2*r'*phi' = F*sin(a)
phi''= v' = (F*sin(a) - 2*r'*phi')/r
Omskrivning:
r = u1          phi = v1
r' = u2         phi' = v2
r'' = u3       phi'' = v3
u3 - u1*v2^2 = F*cos(a) - g/u1^2
u1*v3 + 2*u2*v2 = F*sin(a)
u3 = F*cos(a) - g/u1^2 + u1*(v2)^2
v3 = (F*sin(a) - 2*u2*v2)/u1
y_prim = @(u1, u2) [u2; - (mu/m)*u2 - (g/L)*sin(u1)];
BEGYNNELSEVÄRDEN
t = 0
r = H+1         phi = 0
r' = 0          phi' = 0
a = 90
%}
%% a) Omskrivning av ODE till system av första ordningen
% Se omskrivning ovan
%% b) RK4 program som löser ODE
H = 2;
h = 0.01;
T = 3;
format long;

[tVec, yMtrx, aVec] = RK4(H, h, T);
distVec = yMtrx(:,1)
%plot(tVec, distVec);
hold on
plot(tVec, aVec)



%{
u1 = phi
u2 = phi_prim
u1_prim = u2
u2_prim = - (u/m)*u2 - (g/L)*sin(u1)
%}

function [status, aEND, tEND, distEND] = run_simulation(H, h, T)
    [tVec, yMtrx, aVec] = RK4(H, h, T);
    for i = 1:length(tVec)
        currenct_distance = yMtrx(i, 1);
    end
end



%plot(tVec, distVec);
%hold on;
%plot(tVec, a);
%% Functions
function [tVec, yMtrx, aVec] = RK4(H, h, T)
    g = 20;
    F_0 = g/(1+H)^2;
    F = F_0;
    a_0 = 90;
    aVec(1) = a_0;
    u1 = H+1; u2 = 0;
    v1 = 0; v2 = 0;
    t0 = 0;
    n = (T-t0)/h; 
    tVec = t0:h:T;
    
    % u3 = F*cos(a) - g/u1^2 + u1*(v2)^2
    % v3 = (F*sin(a) - 2*u2*v2)/u1

    yMtrx = [u1, u2, v1, v2]; % Dvs första index i yMtrx innehåller begynnelsevärdena
    y_prim = @(u1, u2, v1, v2, a, F) [u2  ;  F*cos(a) - g/(u1^2) + u1*(v2)^2  ;  v2  ;  (F*sin(a) - 2*u2*v2)/u1];

    for i = 1:n
        u1 = yMtrx(i, 1);
        u2 = yMtrx(i, 2);
        v1 = yMtrx(i, 3);
        v2 = yMtrx(i, 4);

        f1 = y_prim(u1, u2, v1, v2, aVec(i) , F);
        
        f2 = y_prim(u1 + h/2*f1(1), u2 + h/2*f1(2), v1 + h/2*f1(3), v2 + h/2*f1(4), aVec(i) , F);
                    
        f3 = y_prim(u1 + h/2*f2(1), u2 + h/2*f2(2), v1 + h/2*f2(3), v2 + h/2*f2(4), aVec(i) , F);
        
        f4 = y_prim(u1 + h*f3(1), u2 + h*f3(2), v1 + h*f3(3), v2 + h*f3(4), aVec(i) , F);

        yMtrx(i+1, 1) = u1 + h/6*(f1(1) + 2*f2(1) + 2*f3(1) + f4(1));       % r(t)
        yMtrx(i+1, 2) = u2 + h/6*(f1(2) + 2*f2(2) + 2*f3(2) + f4(2));       % r'(t)
        yMtrx(i+1, 3) = v1 + h/6*(f1(3) + 2*f2(3) + 2*f3(3) + f4(3));       % phi(t)
        yMtrx(i+1, 4) = v2 + h/6*(f1(4) + 2*f2(4) + 2*f3(4) + f4(4));       % phi'(t)
        
        %{
                                    yVec = [u0(1) u0(2)]; % Dvs första index i yVec innehåller initialvärdesvektorn u0
                                    % u1_prim = u2;
                                    % u2_prim = - (mu/m)*u2 - (g/L)*sin(u1);
                                    
                                    y_prim = @(u1, u2) [u2; - (mu/m)*u2 - (g/L)*sin(u1)];
                                    
                                    for i = 1:n
                                        u1 = yVec(i, 1);
                                        u2 = yVec(i, 2);


                                        f1 = y_prim(u1, u2);
                                        f2 = y_prim(u1 + h/2*f1(1), u2 + h/2*f1(2));
                                        f3 = y_prim(u1 + h/2*f2(1), u2 + h/2*f2(2));
                                        f4 = y_prim(u1 + h*f3(1), u2 + h*f3(2));


                                        yVec(i+1, 1) = u1 + h/6*(f1(1) + 2*f2(1) + 2*f3(1) + f4(1));
                                        yVec(i+1, 2) = u2 + h/6*(f1(2) + 2*f2(2) + 2*f3(2) + f4(2));
                                    end
                                end
        %}

        phi = yMtrx(i, 3);
        r = yMtrx(i, 1);
        aVec(i+1) = aVec(i) - phi;
        F = g/(r^2);
 
   end
end
